



The chal is an RSA chal, its a fun chal, here is the problem


what we are given:
we are given the public key (e, N) and the ciphertext of the flag (ct1)
In this chal the primes p, q are super large so we can just factor N

But more importantly they gave us something more interesting, which is ct2 = m^(p+q) mod N


Solve:
In general RSA chals, the task is to factorthe modulus N SOMEHOW, then continue the process of decrypting the msg

but in this chal specisifically, i dont there is a solve using the general approach, my approch was to 
basically try to recover the msg directly


Here is my approch:

because the insecure thing in this chal was leaking m^(p+q) mod N
the first thing i thought of was that φ(N) can be written as

φ(N) = (p-1)*(q-1)
       = p*q + 1 - (p+q)
       = N + 1 - (p+q)


what even is φ(N) ? 
well, its called the euler quotion of N, and it is the equal to the product of it primes minus - 1:

example :
let p1, p2, ..., pn be the prime factors of N

the euler quotion can be written as φ(N) = pigma(pi - 1) i: 1 ---> n

and we know in math property that in general a^φ(N) = 1 mod N
you can see that Fermat's little theorm is a special case of this property when N is prime:
if N is prime then it is the only prime factor of itself therefore φ(N) = N-1

a^φ(N) = 1 mod N <=> a^(N-1) = 1 mod N
                   <=> (Fermat's little theorm)





now that we know a^φ(N) = 1 mod N

what if we add 1, let me explain :
a^φ(N) = 1 mod N => a^(φ(N) + 1) = a mod N

this means that if we could raise the plaintext (the flag) to φ(N) + 1 then we get back the flag
since φ(N) = N + 1 - (p+q) and we already have m^(p+q) mod N


we can just inverse the leak and multiply it by m^(N+1) mod N
if we could only calculate m^(N+1) mod N we can get the flag easily, but we can't, i tried but got nothing, we gotta do it another way
its because we dont have m that we cant do this

the path is correct but we need another approch, in fact we dont need m^(N+1) mod N we can just approximate it, but how ?

since they give us ct1 = m^e mod N and e, N are public information, its easy
we can just raise the ct1 by the N/e and we gonna get what we want, let me explain in math:

we have N = α * e + β with β < e and we define γ = e - β - 1, we gonna need this later
thus we have : e = γ + β + 1

if we raise the ct1 to α + 1 we get:
    m^e(α + 1) mod N and multiply it by the inverse of ct2 which is m^(p+q) mod N
    we get:
        m_to_γ = m^e(α + 1) * m^(-(p+q)) mod N
               = m^(eα + e) * m^(-(p+q)) mod N
               = m^(eα + e -(p+q)) mod N
               = m^(eα + γ + β + 1 -(p+q)) mod N        (substitute e)
               = m^(N + γ + 1 - (p+q)) mod N            (N = αe + β)
               = m^(φ(N) + γ) mod N                     (φ(N) = N + 1 - (p+q))
               = m^(φ(N)) * m^(γ) mod N                 (split)
               = 1 * m^γ mod N                   (we know that a^φ(N) = 1 mod N)
               = m^γ mod N


there you go now you know why i called it "m_to_γ"

but so what now that we have m_to_γ
well if you have m to a number and m to another number that are independent of each other meaning (one is not a multiple of the other) then we can recover m, how ?

well the magic is called the Bézout's Lemma, and it says that:
    there exist two uniq x and y such that ax + by = gcd(a, b) for a given a, b
    and the way to calculate x and y is by using the Extended Euclidean Algorithm

again, how will this help us ?

well because we have:
    {ct1 = m^e mod N
    {m_to_γ = m^γ mod N

this means we can recover m to the power of gcd(e, γ), and we are luck because γ < e and e is prime so this means gcd(γ, e) thus we get m exactly.

"γ is gamma not y"

this is how it works, we calculate x, y such that ex + γy = gcd(e, γ) via the Extended Euclidean Algorithm mentioned above
then we use them like this:
    we calculate m = ((ct1 ^ x mod N) * (m_to_γ ^ y mod N)) mod N

there you we just calculated is the original plaintext m its the flag, in the code its the msg
but how ?

this is the math behind it:
((ct1 ^ x mod N) * (m_to_γ ^ y mod N)) mod N = ((m^ex mod N) * (m^γy mod N)) mod N
                                             = m^(ex + γy) mod N
                                             = m^1 mod N                ex + γy = gcd(e, γ) = 1
                                             = m mod N

there is m, the flag

here is the code:


from Crypto.Util.number import *

e = 65537

N = 13172635138210286640933237746072073728198869440440273861514688422430115450596963502627269613634657978751692320585777768877613321668778514462972611542147278205792418292362109100597755668571861738781190210255903465162483813897653948305531342676537057130369323555420200545974179860718822410192595079238246216026529376260568656408216009127973127738250617629330070723654601189310430802429585919291621479622419163092371272056180409609142738265178224163465585013019636286435078812898907472859171136422659050412212315590509027225331104292443193693974638004592849794819591007103879538185323581422819852185166422985403024630123
ct1 = 8499526321488266762028127474977263983474334713646962923180757984708039537289636737028409522654349845032612940144246996001396064450188534247830979105036627472087587636695469693411422088223080856169980341928057477564688506588678465277896123712776169270866525885072607021419929184184301722442524104467963680432737243478200661224741027413690099507128782156810842444314483076587935222998920241102484844741597333281611874849648935849985954902264102662618041817365284648356127737145896858259709819593359264714426125676691235985164360773645489923563993927995838346085066937602961724919392025887999986486672200850129835569774
ct2 = 2263178005282615069738169250508811825030372342139636879043114251227029802177975391784856426659871916802959302578620910469427367218786299839311310420522660987052055310279591316813828952756984548230575321772825193775083404279028090110850848262192595930920326368607665856808251531130234210906413358662814500632504899088517752958423466186872534450108628371006268110210630017230741670440780982809417986017372337888735465439382827207990030719121834402226087906249993820193417658352914727984318783025375497623944699995700474418221251293446038111913247755996471673024017921092527032486774115935601292346440934530921157935322

alpha = N // e
beta = N % e
gamma = e - beta - 1

print(f"{alpha = }")
print(f"{beta = }")
print(f"{gamma = }")

m_to_gamma = (pow(ct1, alpha + 1, N) * pow(ct2, -1, N)) % N

import math
def extended_gcd(a, b):
    """
    Returns (gcd, x, y) such that:
       a * x + b * y = gcd(a, b)
    """
    if a == 0:
        return (b, 0, 1)
    else:
        gcd, x1, y1 = extended_gcd(b % a, a)
        x = y1 - (b // a) * x1
        y = x1
        return (gcd, x, y)

gcd, x, y = extended_gcd(e, gamma)
flag_to_gcd = (pow(ct1, x, N) * pow(m_to_gamma, y, N)) % N
print("here is the flag to the power of ", gcd, ":", long_to_bytes(flag_to_gcd))

